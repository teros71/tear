TODO:

Add handling of recursive shape lists:
- how is appearance applied
- how are shapes spread
- maybe add count for shape lists and a cumulative count also?
- maybe mark a shapelist to be a leaf = no recursive applying?
- appearance inheritance of list shapes?
- parametrize tear algorithm to mark what is the leaf?
- make colour ranges work within a list of colours
- need for "save" operation for generated shapes? Like e.g. generate scaled
  areas to be used for spreading different objects later.
- improve and optimize shape path spreading
- range step improvement: maybe generic step function
  - e.g. fibonacci multiplier or whatever

DONE:
- spread shape path
- spread function (x is generic value/range -> f(x) returns point)
- playground size definitions: pg.HEIGHT & pg.WIDTH
- $CX = center X, $CY = center Y
- fix clumsy area spread outside of area: define area boundaries (take from pg)
- random within colour range
- series value, fibonacci
- function value with generic kwargs
  "args": {"x": y, ...}
- function improvement for getting shape as parameter
  - syntax for adding current shape into the argument list of a function
  - settled for "shape-arg": true
- new functionality: field vector
  - needs to be applied after spreading

values:
x = integer
x.y = float
?:m:n = random between m-n integers or floats
m:n:s = range between m-n with step s
m:n/s = range between m-n divided into s steps
%x%value = x percents of a value
#rrggbb:#rrggbb/s = colour range
?:#rrggbb:#rrggbb/s = random in the colour range (syntax requires step, not used)
[x, y, z] = list
f:str = function where str is evaluated with parameter x (depending no the algorithm)
!:str = series where str is evaluated and should result object with get() method
